解决浏览器传递中文问题

当我们在页面上输入中文后,中文被form表单提交时,GET请求会将表单数据拼接到
URL的抽象路径中.而抽象路径会体现在请求的请求行中.
由于HTTP协议要求请求的请求行和消息头出现的字符只能符合ISO8859-1.因此
中文是不能直接被包含在抽象路径中的.

解决办法:
首先将中文按照页面上指定的字符集转换为2进制。
例如:login.html上，我们指定的字符集为UTF-8
如果输入了中文"范传奇"，浏览器会将其转换为2进制:
111010001000001111100100....
(1个字节8位2进制，"范传奇"按照UTF-8会转换为9个字节总共72位2进制)

2进制可以用字符"0"和"1"表示

因此提交表单时，抽象路径部分:
/myweb/loginUser?username=范传奇&password=123456
就可以用下面内容表示:
/myweb/loginUser?username=111010001000001111100100....&password=123456

上述方式虽然可以用ISO8859-1支持的字符表示不支持的字符进行传递，但是带来
的问题:字符过长

为了缩短长度，我们将2进制以16进制形式表示可以缩短长度，并且依然有效
原因是16进制可以用字符"0"-"9"和"A"-"F"表示。

因此每8位2进制就可以用2位16进制表示了。
2进制         10进制        16进制
0000            0           0
0001            1           1
0010            2           2
0011            3           3
0100            4           4
0101            5           5
0110            6           6
0111            7           7
1000            8           8
1001            9           9
1010            10          A
1011            11          B
1100            12          C
1101            13          D
1110            14          E
1111            15          F

抽象路径可以进一步精简为:
/myweb/loginUser?username=E88C83&password=123456

长度虽然精简了，但是如何与实际的英文数字做区分?
URL地址规定，当我们使用英文和数字表达的是16进制时，那么每2为16进制前面
必须添加一个%
因此实际传输时地址如下:
/myweb/loginUser?username=%E8%8C%83%E4%BC%A0%E5%A5%87&password=123456


服务端在获取信息后需要还原内容，可以使用API提供的类:
URLDecoder

"范"用UTF-8编码转换为2进制和16进制的对照
11101000
E8
10001100
8C
10000011
83
